### **The AURA Development & Bug Fix Plan for Kiro (v2 with Refactoring)**

### **Phase 0: Refactoring and System Stabilization**

**Goal:** Proactively refactor the `Orchestrator` for maintainability, then address all critical bugs to create a stable foundation.

---

#### **Task 0.0: Proactive Refactoring of the Orchestrator**

- **Context from Previous Task:** This is the new first task. Kiro will start with the current codebase.
- **Why:** The `Orchestrator` class is becoming a monolithic "god object". Refactoring it now will create a clean separation of concerns, making the upcoming bug fixes and feature implementations much simpler, safer, and easier to debug.
- **Files to Modify:** `orchestrator.py`.
- **New Files/Directory to Create:** `handlers/__init__.py`, `handlers/base_handler.py`, `handlers/gui_handler.py`, `handlers/conversation_handler.py`, `handlers/deferred_action_handler.py`.
- **Detailed Steps:**

  1.  Create a new directory named `handlers`.
  2.  Inside `handlers`, create a `base_handler.py` file defining an abstract base class (`BaseHandler`) with an `handle()` method.
  3.  Create separate handler classes (`GUIHandler`, `ConversationHandler`, `DeferredActionHandler`) in their own files within the `handlers` directory. Each will inherit from `BaseHandler`.
  4.  **Migrate Logic from `Orchestrator`:**

      - Move the entire logic for GUI interactions (the old `_execute_command_internal` content, including fast path attempts and vision fallback) into the `handle()` method of the `GUIHandler` class.
      - The (currently empty) logic for future conversational chat will go into the `ConversationHandler`.
      - The logic for deferred actions will go into the `DeferredActionHandler`.

  5.  **Simplify the `Orchestrator`:** The `Orchestrator`'s primary role will now be to manage state and route commands. Its `_execute_command_internal` method will be simplified to:

      - Recognize the intent.
      - Instantiate the appropriate handler class (e.g., `handler = GUIHandler(...)`).
      - Call the handler's `handle()` method (e.g., `result = handler.handle(command)`).

---

#### **Task 0.1: Fix Concurrency Deadlock in Deferred Actions**

- **Context from Previous Task:** The `Orchestrator` has been refactored. Its logic is now separated into Handler classes. Kiro will now fix the first critical bug within this new structure.
- **Why:** This is the highest priority bug, causing the application to hang.
- **Files to Modify:** `orchestrator.py` and `handlers/deferred_action_handler.py`.
- **Detailed Steps:**

  1.  The logic for managing the `self.execution_lock` will remain in the main `Orchestrator.execute_command` method.
  2.  After the `Orchestrator` calls the `DeferredActionHandler` and receives a result with status `'waiting_for_user_action'`, it must **release** the `self.execution_lock`.
  3.  The `_on_deferred_action_trigger` method (still in the `Orchestrator`) must **re-acquire** the lock before executing the final action and release it afterward.

---

#### **Task 0.2: Resolve Deferred Action Content Generation Bugs**

- **Context from Previous Task:** The concurrency deadlock has been resolved. The system should no longer hang when interrupted, but the content generated by deferred actions is still flawed, showing duplicate, partial, and poorly formatted output.
- **Why:** The core functionality of the deferred action feature is unreliable and must be fixed.
- **Files to Modify:** `orchestrator.py`, `config.py`.
- **Detailed Steps:**

  1.  **Fix Formatting (Prevention):** In `config.py`, update the `CODE_GENERATION_PROMPT`. Make it stricter with explicit instructions like: `"Ensure the response contains ONLY the raw code. Adhere to proper indentation and newlines. Do not wrap the code in markdown or provide any explanations."`.
  2.  **Fix Duplicate Content (Correction):** In `orchestrator.py`, enhance the `_clean_generated_content` method. Expand the lists of `unwanted_prefixes` and `unwanted_suffixes` to be more comprehensive, catching phrases like "Here is the code:" and markdown code blocks (```) to prevent them from being typed.
  3.  **Fix Formatting (Correction):** In `orchestrator.py`, implement the `_format_single_line_code` method. Inside `_generate_deferred_content`, after cleaning the response, check if the content is a single long line. If so, call this new method to attempt to reformat it with proper newlines and indentation before it is passed to the typing action.
  4.  **Fix Timeout:** In `orchestrator.py`, find the `@with_error_handling` decorator on the `execute_command` method. Remove any `timeout` parameter from this top-level decorator. The long typing process for a deferred action should not be constrained by a short, top-level timeout.

---

#### **Task 0.3: Fix GUI Interaction Failures (`click` and `scroll`)**

- **Context from Previous Task:** Deferred actions are now stable and produce clean content. The final critical bugs are the failures of basic GUI commands like `click` and `scroll`.
- **Why:** Core GUI automation is failing, which undermines AURA's primary purpose.
- **Files to Modify:** `modules/application_detector.py`, `modules/accessibility.py`, `orchestrator.py`.
- **Detailed Steps:**

  1.  **Fix Application Detection:** In `modules/application_detector.py`, refactor the `get_active_application_info` method to be more resilient. Add error handling and a fallback method using AppleScript (`tell application "System Events" to get name of first process whose frontmost is true`) to ensure it can always identify the focused application and fix the `No focused application found` error.
  2.  **Fix `scroll` Context:** In `orchestrator.py`, inside the `_perform_action_execution` method, add a specific check for the `'scroll'` action type. Before executing a scroll, use the `AccessibilityModule` to identify the primary scrollable area on the screen and click its center to ensure it has focus. If no specific scrollable area is found, it can fall back to the current behavior.

---

### **Phase 1: Foundational Architecture and Responsiveness**

**Goal:** With a stable, bug-free system, implement the core architectural changes and user experience enhancements to support all commands in the test report.

- **Task 1.1: Implement Intent Recognition & Orchestrator Routing**

  - **Context from Previous Task:** All major bugs from the report are resolved. The system is stable but still uses regex for all command classification.
  - **Why:** This is the essential architectural upgrade needed for conversational features and to ensure all commands in `report.md` can be correctly categorized.
  - **Detailed Steps:**

    1.  In `config.py`, add the `INTENT_RECOGNITION_PROMPT` to classify commands into categories like `'gui_interaction'`, `'conversational_chat'`, `'deferred_action'`, etc.
    2.  In `orchestrator.py`, create the `_recognize_intent` method to use this prompt.
    3.  Refactor `_execute_command_internal` into an intent-based router that delegates to specific handler methods. Move the entire existing logic from `_execute_command_internal` into a new `_handle_gui_interaction` method.

- **Task 1.2: Implement Whisper Silence Detection**

  - **Context from Previous Task:** The orchestrator is now a smart router. We can now safely improve the audio input pipeline.
  - **Why:** To make AURA feel significantly more responsive, addressing the fixed 8-second recording delay seen in the logs.
  - **Detailed Steps:** In `modules/audio.py`, modify the `speech_to_text` method to record in chunks and stop automatically upon detecting silence, making interactions feel much faster.

---

### **Phase 2: Advanced Content Comprehension**

**Goal:** Build upon the new architecture to give AURA powerful new content understanding capabilities.

- **Task 2.1: Implement "Fast Path" for Content Summarization**

  - **Context from Previous Task:** AURA's architecture is sound and its voice interaction is responsive. We can now add the first major new capability.
  - **Why:** To solve the user's request for fast, non-vision-based summarization of on-screen text, which currently fails or is very slow.
  - **Detailed Steps:**

    1.  **Browser Content:** Create a `get_page_text_content` method in `modules/browser_accessibility.py` to extract all text from a webpage using AppleScript and JavaScript.
    2.  **PDF Content:** Create a new `modules/pdf_handler.py` module to get the file path of an open PDF and extract its text using the `pdftotext` command-line tool.
    3.  **Application Detection:** Update `modules/application_detector.py` to also recognize PDF reader bundle IDs.
    4.  **Orchestrator Integration:** Refactor the `answer_question` method in `orchestrator.py` to use this new text-based fast path for browsers and PDFs before falling back to the vision model.

---

### **Phase 3: Final Feature Implementation**

**Goal:** With a fully stable and capable system, implement the remaining user-facing conversational features from the test report.

- **Task 3.1: Implement the Conversational Chat Handler**

  - **Context from Previous Task:** AURA can now intelligently understand content on the screen. The final step is to enable it to have general conversations.
  - **Why:** To make the "Conversational Chat Commands" in `report.md` fully functional.
  - **Detailed Steps:**

    1.  In `config.py`, add a `CONVERSATIONAL_PROMPT` to define AURA's chat personality.
    2.  In `orchestrator.py`, create the `_handle_conversational_query` method. This handler, called by the intent router, will use the new prompt to get a response from the `ReasoningModule` and speak it to the user.Of course. I understand the request perfectly. You need a single, master implementation plan that integrates the critical bug fixes from your report with the new features we designed. The plan must be structured specifically for Kiro, with each task beginning with a "code-review" context that summarizes the changes from the previous step.

Based on my full analysis of the codebase and the test report, here is the comprehensive and prioritized workflow plan.
